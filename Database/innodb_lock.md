## INNODB LOCK


### 第一部分 前言


InnoDB引擎支持行级别锁，实现了四种隔离级别，本文梳理了InnoDB事务系统及锁系统的原理和源码实现，并且对其中一些比较特别的feature做一个简单的介绍。

因为涉及的模块代码非常庞大，部分实现细节并未深入，如有错漏，欢迎指正。

在介绍InnoDB的事务系统和锁系统之前，有必要对一些基本概念做一个简单的回顾。

我们都知道事务的四大属性ACID，这些属性的保证与数据库中的几大模块紧密的耦合在一起：

- 为了保证原子性Atomicity，数据库需要保证事务要么都成功，要么都不成功，因此需要记事务的undo日志，undo日志保证做了一半的事务可以被全部撤销掉。
- 为了保证持久性Durability，数据库需要保证提交的事务修改的数据能够在各种异常情况下（数据库实例crash，机器故障）都不能丢失，因此需要记事务的redo日志，redo日志保证在事务提交前，事务的修改日志就已经成功落盘。
- 为了保证隔离性Isolation，就需要并发控制了，并发控制机制管理事务的并行执行，使得它们看起来仿佛是单独执行的一样。
以上三点的终极目标是保证数据库事务的一致性Consistency，保证数据从一个一致的状态到另一个一致的状态。

注：这里的一致性与分布式数据库的一致性是不一样的。分布式数据库的一致性是定义了读操作与写操作之间的关系，有强一致性和弱一致性之分。强一致性，或者称为线性一致性，Linearizability，也就是CAP中的C，它要求，每一个读操作都将返回『最近的写操作』（基于单一的实际时间）的值。弱一致性则放宽了这种限制。

分布式数据库的一致性与本文接下来的内容没有关系，只是为了明确它和事务的一致性是不一样的，特在此说明。

### 第二部分  隔离级别


不同隔离级别下，事务有不一样的行为和可容忍的异常，不定义隔离级别就无法去讨论事务系统如何去做事务的并发控制的，因此它是数据库如何保证事务Isolation的前提。

ANSI/ISO SQL-92定义了四种隔离级别（Read Uncommitted, Read Committed, Repeatable Read和Serializable），也是MySQL/InnoDB中实现的四种隔离级别。

InnoDB实现这四种隔离级别的方式可以概括为：

- Read Uncommited
  - 可以读取未提交记录，存在脏读的异常。此隔离级别一般不会使用。
- Read Committed (RC)
  - 针对快照读，不加锁读数据的一个已提交的版本。
  - 针对当前读，RC隔离级别对读取到的记录只加记录锁，因此存在幻读异常。
- Repeatable Read (RR)
  - 针对快照读，不加锁。 
  - 针对当前读，RR隔离级别不仅对读取到的记录加记录锁，同时对读取的范围加锁(间隙锁)，新的在该范围内的记录不能够插入和删除，因此不存在幻读异常。
  - RR是MySQL InnoDB默认的隔离级别。
  
- Serializable
  - 所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。
  - Serializable隔离级别下，读写冲突，相互阻塞，因此并发度急剧下降。

注：众所周知的快照隔离级别（Snapshot Isolation, SI）不在SQL-92定义的四种隔离级别之列，却在很多数据库中实现，如InterBase, PostgreSQL, Oceanbase。在SI下，事务在启动时得到一个数据库的版本号。事务结束时，成功提交仅当它修改的快照的数据项此时没有被外界改变，即没有写写冲突，否则事务回滚。SI能够规避脏读、不可重复读、幻读的异常，但却不是SQL-92定义的无并发异常的可串行化，这是因为SI下可能出现写偏序异常，解决完写偏序异常后的SI被称作可串行化的SI（Serializable SI, SSI），已经被PostgreSQL 9.1采用。

这里出现了当前读和快照读的概念，这与MySQL中基于MVCC的并发控制机制是密不可分的。

### 第三部分  MVCC

MySQL InnoDB存储引擎实现的是基于多版本的并发控制（Multi Version Concurrency Control, MVCC），MVCC的优势耳熟能详：读不加锁，读写操作不会相互阻塞，系统的并发性能高。

MVCC中，读操作可以分为两类：

- 快照读（snapshot read）：读操作读取的是系统的一个一致性快照版本的数据（有可能是历史数据），不需要加锁。
- 当前读（current read）：读取的数据需要是最新的，需要对数据加锁，防止有并发的操作修改。
MySQL InnoDB中哪些操作是快照读，哪些操作是当前读呢？
- 快照读：简单的select ... from ... where ?，在Repeatable Read和Read Committed隔离级别下属于快照读，不加锁。
- 当前读：select ... lock in share mode/select ... for update/insert/update/delete等操作属于当前读，需要加锁。

**InnoDB实现MVCC的关键技术点**
- ROW记录格式
- ROW和undo log关系
- ReadView判断

**ROW格式**

主键  | columns... | DB_TRX_ID | DB_ROLL_PTR


- DB_TRX_ID: 表示这条记录最后一次被变更的事务ID。
- DB_ROLL_PTR: 回滚指针，指向undo。

可通过语句 SHOW EXTENDED COLUMNs from innodb_table_stats; 查看

**读取视图（ReadView）**

- ReadView为活跃事务列表：未提交的事务
- 通过高低水位判断读取的版本
  - low_limit_id 高水位
    - 当前读看不到大于此id的事务修改值
  - up_limit_id低水位
    - 当前读可以看到所有小于此id的事务修改值
  

### 第四部分  锁类型

锁的概念、名词很多，如果没有对锁构建出一个完整的世界观，那么理解起来就会比较有阻碍，接下来我们把这些锁给分一下类。

按照锁的粒度进行划分可以分为：表锁和行锁。

这里就不讨论页锁了，页锁是 BDB（BerkeleyDB） 存储引擎中才有的概念，我们这里主要讨论 InnoDB 存储引擎。

按照兼容性可以把锁划分为：共享锁和排他锁。

被加上共享锁的资源，能够和其他人进行共享，而如果被加上了排他锁，其他人在拿不到这把锁的情况下是无法进行任何操作的。

按照锁的实现，这里的实现就是 InnoDB 中具体的锁的种类了，分别有：

- 意向锁（Intention Locks）
- 记录锁（Record Locks）
- 间隙锁（Gap Locks）
- 临键锁（Next-Key Locks）
- 插入意向锁（Insert Intention Locks）
- 自增锁（AUTO-INC Locks）

即使按照这种分类来对锁进行了划分，看到了这么多的锁的名词可能仍然会有点懵。比如我SELECT ... FOR UPDATE 的时候到底加的是什么锁？

我们应该透过现象看本质，本质是什么？本质是锁到底加在了什么对象上，而这个很好回答：

- 要么加在了表上
- 要么加在了行上


根据作用不同，这些锁又分为以下几种：

**意向锁（Intention Locks）**
意向锁是一种表级锁，它有以下两种类型：
- 意向共享锁（IS）表明该事务打算对表中的记录加共享锁
- 意向排他锁（IX）表明该事务打算对表中的记录加排他锁


例如，SELECT ... FOR SHARE在对应记录行上加锁之前会在对应表上加的意向共享锁，而SELECT .. FOR UPDATE则先会对表加意向排他锁。

意向锁只会和表级别的锁之间发生冲突，而不会和行级锁发生冲突。因为意向锁的主要目的是为了表明有事务即将、或者正在锁定某一行。

**记录锁（Record Locks）**

InnoDB记录锁的锁定对象是对应那行数据所对应的索引，而不是具体的行。也就是说，锁信息并不保存在真正的行数据上。

当一张表没有定义主键时，InnoDB 会创建一个隐藏的RowID，并以此 RowID 来创建聚簇索引。

**间隙锁（Gap Locks）**
官方文档描述：

Gap Lock的唯一目的就是阻止其他事务插入到间隙中。Gap Lock可以同时存在，不同的事务可以同时获取相同的Gap Lock，并不会互相冲突。Gap Lock也是可以显示的被禁止的，只要将事务的隔离级别降低到 READ COMMITTED。

值得注意的是，持有GAP的锁与其他非LOCK_INSERT_INTENTION的锁都是兼容的，也就是说，GAP锁就是为了防止插入的。

**临键锁（Next-Key Locks）**

临键锁（Next-Key Locks）实际上是记录锁和间隙锁的组合。换句话说，临键锁会给对应的索引加上记录锁，并且外加锁定一个区间。这样其他事务就无法向这个区间内新增数据。

在RR隔离级别下，InnoDB 使⽤ Next-Key Locks防⽌幻读。

幻读：在一个事务内，先后执行了两次相同的查询，第一次查询出来 5 条数据，但是第二次再查，查出了 7 条数据，这就是幻读。


**插入意向锁（Insert Intention Locks）**
插入意向锁是间隙锁的一种，在执行INSERT语句时需要加的锁，也是用来避免幻读异常的锁。插入意向锁相互之间不冲突，因此并发的事务在相同的index gap内插入不同的行不需要相互等待。

但实际上，在InnoDB的实现中，在不存在冲突的时候，该锁并不会真正的被创建并加入到锁管理器中去，我们在介绍 INSERT 语句的加锁流程时会做更具体的分析。

**自增锁（AUTO-INC Locks）**

自增锁是一种表级锁，如果一张表存在自增字段 AUTO_INCREMENT，那么事务向该表新增主数据时就会持有自增锁，当语句执行完之后就会释放。在该事务释放自增锁之前，其他的事务不能向该表执行INSERT语句。

实现时，在dict_table_t结构体中有一个autoinc_mutex和autoinc成员变量，用来维护自增字段的值。只在分配时加个mutex即可很快就释放。

因此，在statement格式下不不能保证批量量插⼊操作的binlog复制安全性，因为相同一批INSERT语句分配的自增ID每次可能不相同。


